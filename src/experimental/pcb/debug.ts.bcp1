import { mat3, vec2 } from 'gl-matrix';


/**
 * LINKS:
 *  http://support.seeedstudio.com/knowledgebase/articles/493833-what-is-gerber-file
 *
 Extension                       Layer
 pcbname.GTL                 Top Copper
 pcbname.GTS                 Top Soldermask
 pcbname.GTO                 Top Silkscreen

 pcbname.GBL                 Bottom copper
 pcbname.GBS                 Bottom Soldermask:
 pcbname.GBO                 Bottom Silkscreen:
 pcbname.TXT                  Drills
 pcbname.GML/GKO        *Board Outline:

 4 layer board also need
 pcbname.GL2                   Inner Layer2
 pcbname.GL3                   Inner Layer3


 RS-274X format

 https://www.ucamco.com/files/downloads/file/81/The_Gerber_File_Format_specification.pdf?dd1347f8978ee2fb4532ef5613d36e70

 */



/**
 * TODO add support for complex shapes:
 *  - many areas / perimeters (sub-shapes)
 *  - possibility to add a transform for each sub shape
 *  - possibility to mark shape as additive or subtractive
 */


export class Aperture {
  public readonly origin: vec2;
}

export class GerberImage {

}


export interface IGergerCoordinates {
  x?: number;
  y?: number;
  i?: number;
  j?: number;
}


export class GerberPrecision {
  public readonly int: number;
  public readonly decimal: number;

  constructor(
    int: number,
    decimal: number,
  ) {
    this.int = int;
    this.decimal = decimal;
  }

  toGerberFormatSpecification(): string {
    const _precision: string = `${ this.int.toString(10) }${ this.decimal.toString(10) }`;
    return `%FSLAX${ _precision }Y${ _precision }*%`;
  }

  toGerberCoordinates(coordinates: IGergerCoordinates): string {
    let _coordinates: string = '';
    if (coordinates.x !== void 0) {
      _coordinates += `X${ this.formatNumber(coordinates.x) }`;
    }
    if (coordinates.y !== void 0) {
      _coordinates += `Y${ this.formatNumber(coordinates.y) }`;
    }
    if (coordinates.i !== void 0) {
      _coordinates += `I${ this.formatNumber(coordinates.i) }`;
    }
    if (coordinates.j !== void 0) {
      _coordinates += `J${ this.formatNumber(coordinates.j) }`;
    }
    return _coordinates;
  }

  formatNumber(value: number): string {
    const intString: string = Math.trunc(value) // keep only integer part
      .toString(10) // convert to string
      /*.padStart(this.int, '0')*/;

    const decimalString: string = (value % 1) // keep only decimal part
      .toFixed(this.decimal) // convert to string with a rounder maximum 'decimal' digits
      .slice(2) // remove '0.'
      .padEnd(this.decimal, '0'); // add trailing zeros

    if (intString.length > this.int) {
      throw new Error(`Integer part of the value (${ value }) is greater than the integer precision`);
    }

    return intString + decimalString;
  }
}



export function GenerateGerberUsedUnit(unit: 'mm' | 'inch'): string {
  return `%MO${ (unit === 'mm') ? 'MM' : 'IN' }*%`;
}


/** APERTURE **/

let APERTURE_ID: number = 10;
export function GeFreeApertureID(): number {
  return APERTURE_ID++;
}

export function GenerateGerberApertureCircleTemplate(diameter: number, hole?: number): string {
  return `C,${ diameter.toString(10) }${ (hole === void 0) ? '' : `X${ hole.toString(10) }` }`;
}

export function GenerateGerberApertureRectangleTemplate(width: number, height: number, hole?: number): string {
  return `R,${ width.toString(10) }X${ height.toString(10) }${ (hole === void 0) ? '' : `X${ hole.toString(10) }` }`;
}

export function GenerateGerberApertureObroundTemplate(width: number, height: number, hole?: number): string {
  return `O,${ width.toString(10) }X${ height.toString(10) }${ (hole === void 0) ? '' : `X${ hole.toString(10) }` }`;
}

export function GenerateGerberAperturePolygonTemplate(
  outerDiameter: number,
  numberOfVertices: number,
  rotation?: number,
  hole?: number
): string {
  return `P,${ outerDiameter.toString(10) }X${ numberOfVertices.toString(10) }${ (rotation === void 0) ? '' : `X${ rotation.toString(10) }` }${ ((rotation === void 0) || (hole === void 0)) ? '' : `X${ hole.toString(10) }` }`;
}

export function GenerateGerberApertureDCode(id: number): string {
  return `D${ id.toString(10) }`;
}

export function GenerateGerberApertureDefinition(id: number, template: string): string {
  return `%AD${ GenerateGerberApertureDCode(id) }${ template }*%`;
}

export function GenerateGerberSetCurrentAperture(id: number): string {
  return `${ GenerateGerberApertureDCode(id) }*`;
}

/** OPERATIONS **/

// export function GenerateGerberOperation(precision: ): string {
//   return `%AD${ GenerateGerberApertureDCode(id) }${ template }*%`;
// }

/** GERBER **/

export function GenerateGerber() {
  const precision = new GerberPrecision(3, 3);
  // console.log(precision.formatNumber(123.456789));
  // console.log(precision.formatNumber(2.5));

  const lines: string[] = [
    precision.toGerberFormatSpecification(),
    GenerateGerberUsedUnit('mm'),
    GenerateGerberApertureDefinition(GeFreeApertureID(), GenerateGerberApertureCircleTemplate(0.5)),
  ];

  console.log(precision.toGerberCoordinates({ x: 2.5, y: 2.5 }));

  console.log(lines.join('\n'));
}


/** SHAPES **/

/* SHAPES PATH & SEGMENTS */

export interface IShapePathSegmentOptions {

}

export abstract class ShapePathSegment implements IShapePathSegmentOptions {
  protected constructor(options: IShapePathSegmentOptions) {
  }
}


export interface IShapePathLineToOptions extends IShapePathSegmentOptions {
  end: vec2;
}

export class ShapePathLineTo extends ShapePathSegment implements IShapePathLineToOptions {
  public readonly end: vec2;

  constructor(options: IShapePathLineToOptions) {
    super(options);
    this.end = options.end;
  }
}


export interface IShapePathArcToOptions extends IShapePathSegmentOptions {
  center: vec2;
  angle: number;
}

export class ShapePathArcTo extends ShapePathSegment implements IShapePathArcToOptions {
  public readonly center: vec2;
  public readonly angle: number;

  constructor(options: IShapePathArcToOptions) {
    super(options);
    this.center = options.center;
    this.angle = options.angle;
  }
}


export interface IShapePathOptions {
  origin: vec2;
  segments: Iterable<ShapePathSegment>;
}

export class ShapePath implements IShapePathOptions {

  static lines(points: Iterable<number>): ShapePath {
    const _points: Float32Array = (points instanceof Float32Array)
      ? points
      : new Float32Array(points);

    const length: number = _points.length;
    if (length < 4) {
      throw new Error(`List of points must contain at least 4 values`);
    } else if ((length % 2) !== 0) {
      throw new Error(`List of points must contain an even number of values`);
    }

    const segments: ShapePathLineTo[] = [];

    for (let i = 2; i < length; i += 2) {
      segments.push(new ShapePathLineTo({ end: _points.subarray(i, i + 2) }));
    }

    return new ShapePath({
      origin: _points.subarray(0, 2),
      segments: segments
    });
  }

  static rectangle(width: number, height: number): ShapePath {
    return this.lines(
      new Float32Array([
        0, 0,
        width, 0,
        width, height,
        0, height,
      ])
    );
  }

  static square(side: number): ShapePath {
    return this.rectangle(side, side);
  }

  static circle(center: vec2, radius: number): ShapePath {
    return new ShapePath({
      origin: vec2.fromValues(center[0] + radius, center[1]),
      segments: [
        new ShapePathArcTo({
          center,
          angle: Math.PI * 2
        })
      ]
    });
  }

  public readonly origin: vec2;
  public readonly segments: ShapePathSegment[];

  constructor(options: IShapePathOptions) {
    this.origin = options.origin;
    this.segments = Array.from(options.segments);
  }
  
  applyTransform(transform: mat3): ShapePath {
    throw 'TODO';
  }
}


/*--*/

export type TShapeMode = 'add' | 'sub';

export interface IShapeOptions {
  path: ShapePath;
  transform?: mat3;
  mode?: TShapeMode; // (default: 'add')
}

export abstract class Shape implements IShapeOptions {
  public readonly path: ShapePath;
  public readonly transform: mat3;
  public readonly mode: TShapeMode;

  protected constructor(options: IShapeOptions) {
    this.path = options.path;

    this.transform = (options.transform === void 0)
      ? mat3.create()
      : options.transform;

    this.mode = (options.mode === void 0)
      ? 'add'
      : options.mode;
  }

  abstract toGerber(): string[];
}


export interface IPerimeterShapeOptions extends IShapeOptions {
  thickness: number;
}

export class PerimeterShape extends Shape implements IPerimeterShapeOptions {
  public readonly thickness: number;

  constructor(options: IPerimeterShapeOptions) {
    super(options);
    this.thickness = (options.thickness === void 0)
      ? 0
      : options.thickness;
  }

  toGerber(): string[] {
    throw 'TODO';
  }
}


export interface IAreaShapeOptions extends IShapeOptions {
  sharpness?: number;
}

export class AreaShape extends Shape implements IAreaShapeOptions {
  public readonly sharpness: number;

  constructor(options: IAreaShapeOptions) {
    super(options);
    this.sharpness = (options.sharpness === void 0)
      ? 0
      : options.sharpness;
  }

  toGerber(): string[] {
    throw 'TODO';
  }
}




/*---*/

// export interface IPolygonOptions extends IShapeOptions {
//   points: Iterable<number>;
//   sharpness?: number;
// }
//
// export abstract class Polygon extends Shape implements IPolygonOptions {
//   static rectangle(width: number, height: number): Float32Array {
//     return new Float32Array([
//       0, 0,
//       width, 0,
//       width, height,
//       0, height,
//     ])
//   }
//
//   public readonly points: Float32Array;
//
//   protected constructor(options: IPolygonOptions) {
//     super(options);
//     this.points = new Float32Array(options.points);
//   }
// }
//
// export interface IPolygonAreaOptions extends IPolygonOptions {
//   sharpness?: number;
// }
//
// export class PolygonArea extends Polygon implements IPolygonAreaOptions {
//   public readonly sharpness: number;
//
//   constructor(options: IPolygonOptions) {
//     super(options);
//     this.sharpness = (options.sharpness === void 0)
//       ? 0
//       : options.sharpness;
//   }
//
//   toGerber(): string[] {
//     return [];
//   }
// }
//
//
//
// export interface IRectangleOptions extends Omit<IPolygonOptions, 'points'> {
//   size: vec2;
// }
//
// export class RectangleArea extends PolygonArea implements IRectangleOptions {
//   public readonly size: vec2;
//
//   constructor(options: IRectangleOptions) {
//     super({
//       ...options,
//       points: [
//         0, 0,
//
//       ]
//     });
//   }
//
//   get width(): number {
//     return this.size[0];
//   }
//
//   get height(): number {
//     return this.size[1];
//   }
//
// }


/** RUN **/

export function debugPCB() {
  GenerateGerber();

}



